\section{Introduction}

Determining and managing users needs related to software and hardware is known as
Requirement Engineering (RE). RE is a key phase in the software development. In the past,
RE was considered only in the initial phase of software life cycle, e.g. waterfall model, and it was
not integrated into the remaining software development life cycle. As the time passed, software
development models evolved, and it became part of complete software development life
cycle.
Software systems are developed over millions of lines of code, a number of modules and
documents. The primary goal of the software system is to satisfy users by developing the
software that can meet their needs and expectations. This goal is achievable by applying
different methodologies and engineering techniques. One of the important factors is to understand and
identify the needs of users, also known as, software requirements. Software requirement
engineering is the process that helps to determine the requirements systematically to know
what functionalities the targeted system should have to fulfill users needs. Formally RE is
defined as \cite {Zave:1997} :\\
\textbf{ `` Requirements engineering is the branch of software engineering concerned with the real-world
goals for, functions of, and constraints on software systems. It is also concerned with the
relationship of these factors to precise specifications of software behavior, and to their evolution
over time and across software families.''} \\

	Software requirements plays a key role in the success of a project. In the USA, a survey was
conducted over 8380 projects by 350 companies to know the project failure rates. The report
 \cite{StandishReport} results showed only 16.2\% projects were completed successfully and one-half (52.7\%)
of projects met with challenges and were completed with partial functionalities, time delays and
over budget. Almost 31\% of the projects were never completed. The main cause told by the
executive managers was poor requirements engineering. The major problems were the lack of user
involvement (13\%), requirements incompleteness (12\%), changing requirements (11\%),
unrealistic expectations (6\%), and unclear objectives (5\%). \\

	 Software requirement engineering has mainly four phases; requirement elicitation, requirement
analysis, requirement documentation and requirement verification\cite{Kotonya:1998}. Requirement elicitation
\cite {Coughlan:2002} \cite {Zowghi2005}  helps to understand the stakeholder's needs, e.g. what features he wants in the software.
Requirement elicitation techniques are mostly derived from social sciences, organizational
theory, knowledge engineering and practical experience. For requirements elicitation, different
techniques exist in the literature that include interviews, questionnaires, and ethnography etc.
Requirement analysis \cite{Nuseibeh:2000} is the next step after requirement elicitation. In this phase, software
requirements are analyzed to check conflicts and consistency. It also makes
sure that the requirements are clear, complete and consistent. Furthermore, the agreed
requirements are documented. This documentation has a clear and precise definition of the
system functionalities. It also acts as an agreement between stakeholders and developers. These
functionalities and requirements are documented usually as diagrams, mathematical formulae
or natural languages. These documents are used and iterated until the end of the project.\\

	System requirements are classified into functional requirements (FR), non-functional requirements (NFR), user requirements, business
 requirements. Functional requirements are the system requirements that include the main
features and characteristics of the desired system. Non-functional requirements are the system
properties and constraints \cite{Davis:1993} \cite{Glinz}. NFRs set the criteria for judging the operation of the system such as performance, availability, and reliability etc. Business requirements are specified to address business objective, vision, and goal. It is defined at a higher level from organization or company and considered for designing the products. User requirements are the wish list for the system from users. User requirements are valuable for ensuring the system performs similarly to user needs.\\

\subsection {Machine Learning}
Machine learning (ML) is an emerging field of this era
and is a part of Artificial Intelligence (AI). It helped to solve complicated and hard problems in
software engineering efficiently \cite{Zhang2003}. ML mainly relies on the data and its algorithms learn
from existing datasets. It also helps to predict solutions for unseen problems. Automated learning
processes took great inspiration from human learning i.e. learning from examples. ML algorithms
have proved to have a significant impact in different fields e.g. business, medical, software
engineering, computer security, data and communication networks and others. For the leaning
process algorithm, another key factor are features. Features are the selected properties of a
problem that help in predicting the results. As an example, for a disease diagnostic software,
patient symptoms are the features.  List of symptoms is mapped to the particular disease. Now, if a new patient comes with some symptoms, the system would be able
to predict the disease by learning from the existing dataset. In addition, features help to abstract the complexities of the information
provided for learning. In short, a good selection of features leads to better and faster
learning.\\

	ML algorithms are divided into two major categories; supervised learning and unsupervised
learning \cite{Davis:1993} \cite{kotsiantis2007}. A third category is reinforcement learning which has been added at a
later stage. In supervised learning, data set is labeled. Response to a new input or query
is predicted after learning from the labeled data. All regression and classification
algorithms come under the umbrella of supervised learning e.g. Logistic Regression, Decision
Trees (DT), Support Vector Machine (SVM), Nearest Neighbors (NN), Naive Bayes (NB), Random
Forest and Artificial Neural Network (ANN) etc. \cite{lison2015introduction}. On the other hand, unsupervised learning used unlabeled data. It covers all clustering algorithms e.g. k-means clustering and
hierarchical clustering etc. A supervised classification algorithm learns from the recorded labeled data and on counterpart unsupervised finds similarities between the data and separates data into groups accordingly, assign a new label to each group. Several approaches leveraged a combination of both and known as semi-supervised learning. Semi-supervised learning is a class of supervised learning tasks and techniques that also utilize unlabeled data for training. It uses a small amount of labeled data with a significant amount of unlabeled data to build the predictive model.\cite{SemiSupervisedLearning}